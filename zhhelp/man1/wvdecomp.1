.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "WVDECOMP 1"
.TH WVDECOMP 1 "2007-03-08" " " "ZHTOOLS User guide"
.SH "NAME"
\&\fBwvdecomp\fR \- wavelet decomposition
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBwvdecomp\fR \fIimage\fR \fIoutkey\fR [kernel=gauss/atrous] [threshold=t]
[thresholdmin=tmin] [iter=niter] [scalemin=smin] [scalemax=smax]
[stat=gauss/poisson] [errimg=errorimage] [bg=bgimage] [exp=expimage]
[detectnegative=yes] [considershape=yes/no] [savenoise=yes] [save=yes]
[restore=restorefile] [tmode=nfalse] [tminmode=sig]
.SH "NEWS (for version 2.0)"
.IX Header "NEWS (for version 2.0)"
A new method of computing thresholds for Poisson data is implemented.
With \fBtmode\fR=\fInfalse\fR, you specify the \fBthreshold\fR as the desired number
of false detections in the 512x512 field and \fBthresholdmin\fR as the fraction
of \fBthreshold\fR. It is often desirable that the minimum threshold is set the 
old way, in \*(L"sigmas\*(R"; for that, use \fBtminmode\fR=\fIsig\fR.
.PP
\&\fI\s-1NOTE\s0\fR that the \fInfalse\fR mode is currently implemented only for
\&\fBkernel\fR=\fIgauss\fR.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fIimage\fR" 4
.IX Item "image"
input \s-1FITS\s0 image
.IP "\fIoutkey\fR" 4
.IX Item "outkey"
keyword for output file names. 
.IP "\fBkernel\fR=\fIgauss/atrous\fR" 4
.IX Item "kernel=gauss/atrous"
set the wavelet kernel; see wvdecomp.ps.gz in \f(CW$ZHTOOLS\fR/HELP/Doc directory
for definition of the kernels. kernel=\fIatrous\fR by default.
.IP "\fBsmin\fR=\fIsmin\fR, \fBscalemin\fR=\fIsmin\fR" 4
.IX Item "smin=smin, scalemin=smin"
Set the scale at which the decomposition  process starts. Default value is 1.
.IP "\fBsmax\fR=\fIsmax\fR, \fBscalemax\fR=\fIsmax\fR" 4
.IX Item "smax=smax, scalemax=smax"
Set the scale at which the decomposition stops. Default is \fIscalemax=6\fR.
.Sp
wvdecomp writes a set of output images, \fIoutkey\fR and \fIoutkey\fR.i, where
\&\fIsmin\fR <= i <= \fIsmax\fR+1.  \fIoutkey\fR.i contains flux detected on scale
\&\f(CW\*(C`i\*(C'\fR. \fIoutkey\fR equals sum of \fIoutkey\fR.i for i=smin,smax.
\&\fIoutkey\fR.[smax+1] contains is the residual image smoothed with the kernel
at the largest scale.
.IP "\fBt\fR=\fIt\fR, \fBthreshold\fR=\fIt\fR" 4
.IX Item "t=t, threshold=t"
Set the detection threshold, in sigma. Default is \fBthreshold\fR=3. However,
this is too low for most applications; e.g., there will be many false
detections in a 512x512 image with \fBt\fR=3; \fBthreshold\fR=4.5\-5 is a
reasonable choice in most cases. It is possible to set individual detection
threshold for each scale.  For that, use \fBthreshold\fR=\fIta,tb,...\fR syntax,
where \fIta\fR is the threshold at \fIsmin\fR and so on.
.IP "\fBtmin\fR=\fItmin\fR, \fBthresholdmin\fR=\fItmin\fR" 4
.IX Item "tmin=tmin, thresholdmin=tmin"
This parameter, the filtering threshold, is explained in
\&\f(CW$ZHTOOLS\fR/HELP/Doc/wvdecomp.ps.gz. Its default value equals the detection
threshold at the given scale; \fBtmin\fR=2.5 or more is a good choice. It is
possible to set individual tmin's for all scales with the same syntax as for
the threshold parameter.
.IP "\fBtmode\fR=\fInfalse\fR" 4
.IX Item "tmode=nfalse"
This option specifies that detection thresholds are set as a number of false 
detections in the 512x512 field. In this case, \fBtmin\fR is specified as a
fraction of the threshold. If you want to specify \fBtmin\fR in terms of
\&\*(L"sigmas\*(R", use the \fBtminmode\fR=\fIsig\fR option.
.IP "\fBtminmode\fR=\fIsig\fR" 4
.IX Item "tminmode=sig"
This option specifies that the minimum thresholds are in \*(L"sigmas\*(R" even if
\&\fBtmode\fR=\fInfalse\fR
.IP "\fBiter\fR=\fIniter\fR" 4
.IX Item "iter=niter"
Set the number of iterations at each scale. The decomposition process is
repeated at the same scale until no new structures are detected or until
\&\fIniter\fR iterations are made. This parameter defaults to 1. A reasonable
choice is \fBiter\fR=5.
.IP "\fBstat\fR=\fIpoisson/gauss\fR" 4
.IX Item "stat=poisson/gauss"
Set the statistics of the image noise. This parameter defaults to
\&\fIpoisson\fR; however, if \fIerrimg\fR is supplied, \fBstat\fR=\fIgauss\fR is the
default.
.IP "\fBerrimg\fR=\fIerrorimage\fR" 4
.IX Item "errimg=errorimage"
You can supply the image containing standard deviations in the data in each
pixel. If this parameter is not set, the noise will be estimated from the
data assuming either Poisson or Gaussian statistics (the statistics used can
be controlled by the \fIstat\fR parameter).
.IP "\fBbg\fR=\fIbgimage\fR" 4
.IX Item "bg=bgimage"
Sometimes it is practical to subtract the known structures from the data
before the wavelet decomposition. For example, in the case of the \s-1ROSAT\s0 \s-1PSPC\s0
data, one may want to subtract the normalized exposure map to get rid of
spurious detections around the \s-1PSPC\s0 window support structure. If the image
noise is Gaussian, this ``background'' can be subtracted in
advance. However, if it is desirable to preserve Poisson statistics, the
subtraction must be done internally. This is the purpose of the \fBbg\fR
parameter.
.IP "\fBexp\fR=\fIexpimage\fR" 4
.IX Item "exp=expimage"
Similar to \fBbg\fR, but uses the exposure map to correct the data. Image is
divided by the exposure map before convolution with the wavelet kernel, and
multiplied back by exposure upon the convolution. This preserves Poisson
statistics, but eliminates false detections in the region of strongly
varying exposure.
.IP "\fBdetectnegative\fR=yes" 4
.IX Item "detectnegative=yes"
detect both positive and negative features. default is no
.IP "\fBconsidershape\fR=yes/no" 4
.IX Item "considershape=yes/no"
If \fBconsidershape\fR=\fIyes\fR wvdecomp will try to avoid detection of ring-like
structures. This is desirable if if one wants to exclude negative rings
around bright sources when \fBdetectnegative\fR is on. default is no but
switches to yes if \fBdetectnegative\fR=yes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The wavelet decomposition algorithm is described in Vikhlinin et al. 1998,
ApJ, 502, 558. Additional information can be found in
\&\f(CW$ZHTOOLS\fR/HELP/Doc/wvdecomp.ps.gz and references therein.
.SH "MEMORY REQUIREMENTS"
.IX Header "MEMORY REQUIREMENTS"
wvdecomp memory usage in Mb can be estimated as 0.3+7*nx*ny/(512**2), where
(nx,ny) is the size of the input image.
.PP
To find connected detected structures, wvdecomp uses the so called flood
fill algorithm. It usues repeated recursive calls of a C function. If
\&\fBthersholdmin\fR is set too low (or, e.g., wrong type of noise statistics is
specified) the connected structures often have complicate shapes and
fill large areas. This requires too many calls of the flood fill
algorithm and wvdecomp crashes with segmentation fault. If this happens
but you feel that detections thresholds are set correctly, try
increasing the stack size (see \f(CW$ZHTOOLS\fR/G77.README for possible ways of
doing this).
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Sh "1) \s-1WVDECOMP\s0 as a background map tool"
.IX Subsection "1) WVDECOMP as a background map tool"
The best approximation to the background is the smoothed data from which all
detectable sources were subtracted. This is exactly what the largest scale
of the wavelet decomposition contains. So, after we run something like
.PP
.Vb 2
\& wvdecomp image bg scalemin=1 scalemax=6 threshold=3 \e
\&              thresholdmin=2  iter=10
.Ve
.PP
the image \fIbg.7\fR contains a good approximation to the background in
\&\fIimage\fR. Note that in this example, thresholds were set low, because we
were interested not in the confident source detection but rather in a
complete source subtraction.
.Sh "2) Subtraction of point sources to study large structures"
.IX Subsection "2) Subtraction of point sources to study large structures"
This is similar to the previous example, with two exceptions. First, we
should stop the wavelet decomposition at small scale, because we would like
to subtract only point sources. Second, we may not want to smooth the
resulting image. 
.PP
Suppose, scale 3 is already larger than the point source, but still much
smaller than the structures of interest.
.PP
.Vb 2
\& wvdecomp image point scalemin=1 scalemax=3 threshold=3 \e
\&   thresholdmin=2 iter=10
.Ve
.PP
creates the image of point sources, \fIpoint\fR. Subtraction of \fIpoint\fR from
the \fIimage\fR produces the desired map.
.SH "BUGS"
.IX Header "BUGS"
Image header keywords are not copied from the input image. Use \fBcopyheader\fR 
of \fBcphead\fR from \s-1FTOOLS\s0 to update headers of output images, if necessary.
.SH "AUTHOR"
.IX Header "AUTHOR"
Alexey Vikhlinin <alexey@head\-cfa.harvard.edu>
